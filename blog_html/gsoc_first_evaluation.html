      <section class="resume-section p-3 p-lg-5 d-flex flex-column" id="interests">
        <div class="my-auto">
          <h3 class="mb-5">First Evaluation GSoC'18</h3>
          
          <p class="mb-0">
            This blog describes the work done for first evaluation of <b>Google Summer of Code</b>, hope you enjoy it :)
          </p>
          
          <p class="mb-5">
          	In the community bonding period I went over the code, read documentation, updated my timeline. I also did some reviewing of other's ticket and tried to fix some easy bugs. I reviewed the following tickets:
          	
          </p>
          <ul style="list-style-type:disc">
          	<li>
          		<a href="https://trac.sagemath.org/ticket/25242"><b>#25242</b></a>
          	</li>
          	<li>
          		<a href="https://trac.sagemath.org/ticket/25156"><b>#25156</b></a>
          	</li>
          </ul>

          <p>
          For bug fixing I worked on (still working on it :P ):
          </p>
          
          <ul style="list-style-type:disc">
          	<li>
          		<a href="https://trac.sagemath.org/ticket/24850"><b>#24850</b></a>
          	</li>
          </ul>

          <p>
          	Now lets start with the main project, First part of my project was to implement
          	<a href="https://arxiv.org/abs/1403.6501"><i>Doyle-Krumm Algorithm-4.</i></a> This algorithm
          	provides an efficient method to compute all elements of a number field (<b>K</b>) having
          	realtive height at most <b>B</b>. Initially in <b>sage</b> Algorithm-3 was implemented. 
          	So why implement algorithm-4??
          </p>

          <p>
          	A computer has a limited memory, hence there is a limit of storing data. Issues are due to the fact that in a computer we cannot work exactly with the real numbers that appear in the algorithm (heights of algebraic numbers, logarithms of real numbers, absolute values of algebraic numbers), so we must make do with rational approximations of them. Consider the 
          	following example:
          </p>

          	<pre>
          		<code>
sage: from sage.rings.number_field.bdd_height import bdd_height
sage: K.&lt;v&gt; = NumberField(x^3 + x + 1)
sage: bound = 3
sage: list(bdd_height(K,bound))
sage: for x in T:
.... 	print x, e**(K(x).global_height()*K.degree())
0 1.00000000000000
-v^2 + v - 1 2.14789903570479
v^2 - v + 1 2.14789903570479
v^2 + 1 1.46557123187677
-v^2 - 1 1.46557123187677
-1 1.00000000000000
1 1.00000000000000
-v 1.46557123187677
v 1.46557123187677
-v^2 2.14789903570479
v^2 2.14789903570479
          		</code>
          	</pre>

          <p>
          	If we change the bound to just 3.1 we get:
          </p>
          	
          	<pre>
          		<code>
sage: from sage.rings.number_field.bdd_height import bdd_height
sage: K.&lt;v&gt; = NumberField(x^3 + x + 1)
sage: bound = 3.1
sage: list(bdd_height(K,bound))
sage: for x in T:
.... 	print x, e**(K(x).global_height()*K.degree())
0 1.00000000000000
-v^2 + v - 1 2.14789903570479
v^2 - v + 1 2.14789903570479
v^2 + 1 1.46557123187677
-v^2 - 1 1.46557123187677
-1 1.00000000000000
1 1.00000000000000
-v 1.46557123187677
v 1.46557123187677
-v^2 2.14789903570479
v^2 2.14789903570479
-2/3*v^2 + 1/3*v - 1/3 3.00000000000000
-v^2 + v 3.00000000000000
2/3*v^2 - 1/3*v + 1/3 3.00000000000000
v^2 - v 3.00000000000000
1/3*v^2 + 1/3*v + 2/3 3.00000000000000
-v + 1 3.00000000000000
-1/3*v^2 - 1/3*v - 2/3 3.00000000000000
v - 1 3.00000000000000
1/3*v^2 + 1/3*v - 1/3 3.00000000000000
-v^2 - 2 3.00000000000000
-1/3*v^2 - 1/3*v + 1/3 3.00000000000000
v^2 + 2 3.00000000000000
          		</code>
          	</pre>

          <p>
          	So with example above it is clear that we were missing points whose height
          	was exactly 3 (due to approximation of real numbers). <b>Algorithm-4</b> provides a convinent way of finding approximations that are good enough to gurantee correct results.
          </p>
        
        </div>
      </section>